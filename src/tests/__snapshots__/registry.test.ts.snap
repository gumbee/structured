// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Integration > should handle complex nested structures with arrays and unions 1`] = `
"type Badge = {
  type: "badge"
  label: string
  color: "red" | "green" | "blue"
}

type Avatar = {
  type: "avatar"
  src: string
  alt: string | undefined
}

type ListItem = {
  type: "list-item"
  content: string
  badges: Badge[]
  avatar: Avatar | undefined
}

type List = {
  type: "list"
  items: ListItem[]
  title: string | undefined
}"
`;

exports[`Integration > should use schemaToTypescript with custom type name for single schema output 1`] = `
"/**
 * An icon
 */
type Icon = {
  type: "icon"
  name: string
}

/**
 * A button
 */
type MyButton = {
  type: "button"
  label: string
  icon: Icon | undefined
}"
`;

exports[`Integration > should work end-to-end: register, collect deps, generate TypeScript 1`] = `
"/**
 * An icon component
 */
type Icon = {
  type: "icon"
  name: string
  size: "small" | "medium" | "large" | undefined
}

/**
 * A text component
 */
type Text = {
  type: "text"
  content: string
}

/**
 * A card with icon and title
 */
type Card = {
  type: "card"
  icon: Icon | undefined
  title: Text
}"
`;

exports[`Utility Schemas > registryToTypescript > should allow utility schema to be referenced from multiple schemas 1`] = `
"// --- Utility Types ---

type Dimensions = {
  width: number
  height: number
}

// --- Main Types ---

type Image = {
  type: "image"
  src: string
  dimensions: Dimensions
}

type Video = {
  type: "video"
  src: string
  dimensions: Dimensions
}"
`;

exports[`Utility Schemas > registryToTypescript > should not show section headers when there are no utility schemas 1`] = `
"type Icon = {
  type: "icon"
  name: string
}

type Text = {
  type: "text"
  content: string
}"
`;

exports[`Utility Schemas > registryToTypescript > should not show section headers when there are only utility schemas 1`] = `
"type Color = {
  r: number
  g: number
  b: number
}

type Size = "small" | "medium" | "large""
`;

exports[`Utility Schemas > registryToTypescript > should render utility schemas as named types, not inlined 1`] = `
"// --- Utility Types ---

type Color = {
  r: number
  g: number
  b: number
}

// --- Main Types ---

type Button = {
  type: "button"
  label: string
  color: Color
}"
`;

exports[`Utility Schemas > registryToTypescript > should separate utility schemas into a dedicated section with headers 1`] = `
"// --- Utility Types ---

/**
 * Size options
 */
type Size = "small" | "medium" | "large"

// --- Main Types ---

/**
 * An icon component
 */
type Icon = {
  type: "icon"
  name: string
  size: Size
}"
`;

exports[`Utility Schemas > schemaToTypescript > should handle nested utility schema dependencies 1`] = `
"// --- Utility Types ---

type Color = {
  r: number
  g: number
  b: number
}

type Border = {
  width: number
  color: Color
}

// --- Main Types ---

type Card = {
  type: "card"
  title: string
  border: Border
}"
`;

exports[`Utility Schemas > schemaToTypescript > should include utility schema dependencies in a separate section 1`] = `
"// --- Utility Types ---

/**
 * RGB color
 */
type Color = {
  r: number
  g: number
  b: number
}

// --- Main Types ---

/**
 * A button component
 */
type Button = {
  type: "button"
  label: string
  backgroundColor: Color
}"
`;

exports[`Wrapped utility schema resolution > registryToTypescript > should reference utility enum by name when used with .alias().flexible().describe() 1`] = `
"// --- Utility Types ---

type BodyPart = "chest" | "arms" | "legs" | "head"

// --- Main Types ---

type Symptom = {
  name: string
  bodyPart: BodyPart // The affected body part
}"
`;

exports[`Wrapped utility schema resolution > registryToTypescript > should reference utility enum by name when used with only .describe() 1`] = `
"// --- Utility Types ---

type BodyPart = "chest" | "arms" | "legs" | "head"

// --- Main Types ---

type Symptom = {
  name: string
  bodyPart: BodyPart // The affected body part
}"
`;

exports[`Wrapped utility schema resolution > schemaToTypescript > should auto-detect utility type dependency without always: true 1`] = `
"// --- Utility Types ---

type BodyPart = "chest" | "arms" | "legs"

// --- Main Types ---

type Symptom = {
  name: string
  bodyPart: BodyPart // The affected area
}"
`;

exports[`Wrapped utility schema resolution > schemaToTypescript > should detect nested utility dependencies through wrapper chains 1`] = `
"// --- Utility Types ---

type BodyPart = "chest" | "arms" | "legs"

type Symptom = {
  name: string
  bodyPart: BodyPart // The body part
}

// --- Main Types ---

type SymptomList = {
  title: string | undefined
  symptoms: Symptom[] // List of symptoms
}"
`;

exports[`Wrapped utility schema resolution > schemaToTypescript > should reference utility type inside .extend()-ed schema fields 1`] = `
"// --- Utility Types ---

type BodyPart = "chest" | "arms" | "legs"

// --- Main Types ---

type ExtendedSymptomList = {
  symptoms: {
    name: string
    bodyPart: BodyPart // The body part
    severity: number // Severity level
  }[] // Extended symptoms
}"
`;

exports[`registryToTypescript > should convert PascalCase type names 1`] = `
"type MyWidget = string

type AnotherWidget = number"
`;

exports[`registryToTypescript > should convert all schemas to type definitions 1`] = `
"type Icon = {
  type: "icon"
  name: string
}

type Text = {
  type: "text"
  content: string
}"
`;

exports[`registryToTypescript > should generate complete type definitions with nested objects 1`] = `
"/**
 * An icon component
 */
type Icon = {
  type: "icon"
  name: string
  size: number | undefined
}

/**
 * A button with optional icon
 */
type Button = {
  type: "button"
  label: string
  icon: Icon | undefined
}"
`;

exports[`registryToTypescript > should include both description and rules in JSDoc 1`] = `
"/**
 * A code identifier
 * Rules: Must be alphanumeric
 */
type Code = string"
`;

exports[`registryToTypescript > should include description as JSDoc 1`] = `
"/**
 * A text label
 */
type Label = string"
`;

exports[`registryToTypescript > should include rules as JSDoc 1`] = `
"/**
 * Rules: Must be alphanumeric
 */
type Code = string"
`;

exports[`registryToTypescript > should not duplicate types when dependencies are referenced multiple times 1`] = `
"type Shared = {
  type: "shared"
  id: string
}

type A = {
  type: "a"
  shared: Shared
}

type B = {
  type: "b"
  shared: Shared
}"
`;

exports[`schemaToTypescript > should convert array schema 1`] = `"type Output = string[]"`;

exports[`schemaToTypescript > should convert boolean schema 1`] = `"type Output = boolean"`;

exports[`schemaToTypescript > should convert enum schema 1`] = `"type Output = "small" | "medium" | "large""`;

exports[`schemaToTypescript > should convert literal schema 1`] = `"type Output = "icon""`;

exports[`schemaToTypescript > should convert nullable schema 1`] = `"type Output = string | null"`;

exports[`schemaToTypescript > should convert number schema 1`] = `"type Output = number"`;

exports[`schemaToTypescript > should convert object schema 1`] = `
"type Output = {
  type: "icon"
  name: string
}"
`;

exports[`schemaToTypescript > should convert optional schema 1`] = `"type Output = string | undefined"`;

exports[`schemaToTypescript > should convert string schema with custom type name 1`] = `"type CustomName = string"`;

exports[`schemaToTypescript > should convert string schema with default type name 1`] = `"type Output = string"`;

exports[`schemaToTypescript > should convert union schema 1`] = `"type Output = string | number"`;

exports[`schemaToTypescript > should handle deeply nested dependencies 1`] = `
"type Leaf = {
  type: "leaf"
  value: string
}

type Branch = {
  type: "branch"
  leaf: Leaf
}

type Tree = {
  type: "tree"
  branches: Branch[]
}"
`;

exports[`schemaToTypescript > should handle mixed fields with and without descriptions 1`] = `
"type Output = {
  id: number
  name: string // The user's full name
  email: string
  phone: string | undefined // Contact phone number
}"
`;

exports[`schemaToTypescript > should include JSDoc from registry metadata 1`] = `
"/**
 * A user object
 * Rules: Name must be unique
 */
type User = {
  id: number
  name: string
}"
`;

exports[`schemaToTypescript > should include field descriptions as inline comments 1`] = `
"type Output = {
  home: string // The home of the user
  age: number // The age in years
}"
`;

exports[`schemaToTypescript > should include field descriptions in nested objects 1`] = `
"type Output = {
  user: {
    name: string // User's name
    settings: {
      theme: string // UI theme preference
    }
  }
}"
`;

exports[`schemaToTypescript > should include field descriptions when describe is called on optional 1`] = `
"type Output = {
  bio: string | undefined // A short biography
}"
`;

exports[`schemaToTypescript > should include field descriptions when wrapped with nullable 1`] = `
"type Output = {
  middleName: string | null // Middle name if any
}"
`;

exports[`schemaToTypescript > should include field descriptions when wrapped with optional 1`] = `
"type Output = {
  nickname: string | undefined // An optional nickname
}"
`;

exports[`schemaToTypescript > should include referenced registry types as standalone types 1`] = `
"/**
 * An icon component
 */
type Icon = {
  type: "icon"
  name: string
}

type Container = {
  items: Icon[]
}"
`;
